<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>PL/0 language compiler(in PASCAL) | ydleenudt</title>
  <meta name="author" content="Victor Lee">
  
  <meta name="description" content="CS as well as Medcine">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="PL/0 language compiler(in PASCAL)"/>
  <meta property="og:site_name" content="ydleenudt"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="ydleenudt" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">ydleenudt</a></h1>
  <h2><a href="/">Life&#39;s A Struggle</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">存档</a></li>
    
      <li><a href="about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-06-26T17:23:56.000Z"><a href="/2015/06/27/PL-0-language-compiler-in-PASCAL/">2015-06-27</a></time>
      
      
  
    <h1 class="title">PL/0 language compiler(in PASCAL)</h1>
  

    </header>
    <div class="entry">
      
        <h3 id="PL/0语言分析程序（in_pascal）">PL/0语言分析程序（in pascal）</h3><h4 id="General_Information">General Information</h4><ul>
<li>PL/0语言编译程序的语法分析技术采用的是自顶向下递归子程序法</li>
<li>PL/0语言编译程序的整体结构包括词法分析、语法分析、语义分析、代码生成及符号表管理，每个过程的功能相互联系</li>
<li>PL/0语言编译程序的目标程序在运行时采用栈式动态存储管理的实现技术</li>
<li>◇标识符的有效长度是10<br>◇ 数字最多为14位<br>◇ 过程最多可嵌套三层，可递归调用<br>◇ 标识符的作用域同PASCAL，内层可引用包围它的外层定义的标识符（如：变量名，过程名，常量名）</li>
<li>编译过程采用一趟扫描方式，以语法分析程序为核心，词法分析程序和代码生成程序都作为一个独立的过程，当语法分析需要读单词时就调用词法分析程序，而当语法分析正确需生成相应的目标代码时，则调用代码生成程序。</li>
<li>用出错处理程序对词法和语法分析遇到的错误给出在源程序中出错的位置和错误性质</li>
<li>用表格管理程序建立变量、常量和过程标识符的说明与引用之间的信息联系</li>
</ul>
<h4 id="语法描述">语法描述</h4><p>程序语法描述<br><img src="http://ww4.sinaimg.cn/large/a656b2e0gw1ethzrk6xkej205n00zt8k.jpg" alt="程序语法描述"></p>
<p>分程序语法描述<br><img src="http://ww4.sinaimg.cn/large/a656b2e0gw1ethzsdrvlsj20ba09ot9k.jpg" alt="分程序语法描述"></p>
<p>语句语法描述图<br><img src="http://ww2.sinaimg.cn/large/a656b2e0gw1ethzszev8ej20by0bvjss.jpg" alt="语句语法描述图"></p>
<p>条件语法描述图（带条件转换的boolean语句）<br><img src="http://ww1.sinaimg.cn/large/a656b2e0gw1ethztiluu7j20by043jrq.jpg" alt="条件语法描述图"></p>
<p>表达式语法描述<br><img src="http://ww1.sinaimg.cn/large/a656b2e0gw1ethztznmbxj20by03j3yl.jpg" alt="表达式语法描述"></p>
<p>项语法描述<br><img src="http://ww2.sinaimg.cn/large/a656b2e0gw1ethzuo4scdj20by046t8s.jpg" alt="项语法描述"></p>
<p>因子语法描述<br><img src="http://ww2.sinaimg.cn/large/a656b2e0gw1ethzv69pisj20by044jrj.jpg" alt="因子语法描述"></p>
<h4 id="BNF表示">BNF表示</h4><p>PL/0语言文法的EBNF表示为：<br>　　〈程序〉∷=〈分程序〉．<br>　　〈分程序〉∷=[〈常量说明部分〉][〈变量说明部分〉][〈过程说明部分〉]〈语句〉<br>　　〈常量说明部分〉∷=CONST〈常量定义〉 {，〈常量定义〉}；<br>　　〈常量定义〉∷=〈标识符〉=〈无符号整数〉<br>　　〈无符号整数〉∷=〈数字〉{〈数字〉}<br>　　〈变量说明部分〉∷=VAR〈标识符〉{，〈标识符〉}；<br>　　〈标识符〉∷=〈字母〉{〈字母〉|〈数字〉}<br>　　〈过程说明部分〉∷=〈过程首部〉〈分程序〉{；〈过程说明部分〉}；<br>　　〈过程首部〉∷=PROCEDURE〈标识符〉；<br>　　〈语句〉∷=〈赋值语句〉|〈条件语句〉|〈当型循环语句〉|〈过程调用语句〉|〈读语句〉|〈写语句〉|〈复合语句〉|〈空〉<br>　　〈赋值语句〉∷=〈标识符〉∶=〈表达式〉<br>　　〈复合语句〉∷=BEGIN〈语句〉{；〈语句〉}END<br>　　〈条件〉∷=〈表达式〉〈关系运算符〉〈表达式〉|ODD〈表达式〉<br>　　〈表达式〉∷=[+|-]〈项〉{〈加法运算符〉〈项〉}<br>　　〈项〉∷=〈因子〉{〈乘法运算符〉〈因子〉}<br>　　〈因子〉∷=〈标识符〉|〈无符号整数〉|’(‘〈表达式〉’)’<br>　　〈加法运算符〉∷=+|-<br>　　〈乘法运算符〉∷=*|/<br>　　〈关系运算符〉∷=#|=|＜|＜=|＞|＞=<br>　　〈条件语句〉∷=IF〈条件〉THEN〈语句〉<br>　　〈过程调用语句〉∷=CALL〈标识符〉<br>　　〈当型循环语句〉∷=WHILE〈条件〉DO〈语句〉<br>　　〈读语句〉∷=READ’(‘〈标识符〉{，〈标识符〉}’)’<br>　　〈写语句〉∷=WRITE’(‘〈表达式〉{，〈表达式〉}’)’<br>　　〈字母〉∷=a|b|…|X|Y|Z<br>　　〈数字〉∷=0|1|2|…|8|9</p>
<h4 id="类pcode部分">类pcode部分</h4><p>目标指令有8条：<br>　　① LIT：将常量值取到运行栈顶。a域为常数值。<br>　　② LOD：将变量放到栈顶。a域为变量在所说明层中的相对位置,l为调用层<br>　　与说明层的层差值。<br>　　③ STO：将栈顶的内容送入某变量单元中。a,l域的含意同LOD指令。<br>　　④ CAL：调用过程的指令。a为被调用过程的目标程序入口地址，l为层差。<br>　　⑤ INT：为被调用的过程(或主程序)在运行栈中开辟数据区。a域为开辟的单元个数。<br>　　⑥ JMP：无条件转移指令，a为转向地址。<br>　　⑦ JPC：条件转移指令，当栈顶的布尔值为非真时，转向a域的地址，否则顺序执行。<br>　　⑧ OPR：关系运算和算术运算指令。将栈顶和次栈顶的内容进行运算，结果存放在次栈顶，此外还可以是读写等特殊功能的指令，具体操作由a域值给出。（详见解释执行程序）。</p>
<p>类pcode代码指令的详细解释（指令功能表见实验指导）<br>　　目标代码类pcode是一种假想栈式计算机的汇编语言。<br>　　指令格式：f+l+a<br>　　f 功能码<br>　　l 层次差 （标识符引用层减去定义层）<br>　　a 根据不同的指令有所区别</p>
<p>一个PL/0程序与目标代码类pcode指令的映射例子<br><img src="http://ww2.sinaimg.cn/large/a656b2e0gw1ethzvydb7zj20bz0awdiq.jpg" alt="一个PL/0程序与目标代码类pcode指令的映射例子"></p>
<h4 id="词法分析">词法分析</h4><p>全程量单元（global variable）：</p>
<ul>
<li>SYM：存放每个单词的类别，用内部编码形式表示。</li>
<li>ID：存放用户所定义的标识符的值。即标识符字符串的机内表示。<br><code>alpha</code>in code</li>
<li>NUM：存放用户定义的数。</li>
</ul>
<p>全程量单元定义在<code>procedure plcompiler</code>中<br><strong>CODE</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch:char;           &#123; last character read &#125;&#10;sym:symbol;        &#123; last symbol read&#125;&#10;id:alfa;           &#123; last identifier read  10&#125;</span><br></pre></td></tr></table></figure></p>
<p>单词（word）：</p>
<ul>
<li>基本字：也可称为保留字或关键字，如BEGIN，END，IF，THEN等。<br><code>oobject</code> in code representing (constant,typel,variable,prosedure)<br><code>types</code> in code representing (notyp,ints,chars,bool,arrays)</li>
<li>运算符：如：+、-、*、／、∶=、#、＞=、＜=等。</li>
<li>标识符：用户定义的变量名、常数名、过程名。</li>
<li>常数：如：10，25，100等整数。</li>
<li>界符：如：’，’、’.’、’；’、’(‘、’)’等。</li>
</ul>
<p><strong>单词的全部种类存放在symbol中</strong><br>词法分析过程GETSYM<br><img src="http://ww2.sinaimg.cn/large/a656b2e0gw1ethzwj7qxbj20by0fntah.jpg" alt="词法分析过程GETSYM"><br><code>procedure getsym</code>中对标识符和关键字（保留字）的识别方式为：</p>
<ul>
<li>当识别到字母开头的字母数字串时，先查关键字表</li>
<li>若查不到则为标识符，查到则为关键字。</li>
</ul>
<p>PL/0编译程序文本中主程序开始对关键字表置初值如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word[1]:=&#39;begin &#39;&#65307;word[2]:=&#39;call &#39;&#65307;&#10;&#123;etc.&#125;&#10;word[13]:=&#39;write &#39;&#65307;</span><br></pre></td></tr></table></figure></p>
<p>每个数组元素的字符长度为10，不满10个字符时，以空格补满。<br>查到时找到关键字相应的内部表示为：<br><figure class="highlight pl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wsym[<span class="number">1</span>]:=beginsym; wsym[<span class="number">2</span>]:=callsym；</span><br><span class="line">&#123;etc.&#125;</span><br><span class="line">wsym[<span class="number">13</span>]:=writesym；</span><br></pre></td></tr></table></figure></p>
<p><code>procedure getsym</code>的结构为<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procedure getsym;&#10;    procedure getch;&#10;    begin&#10;    &#123;code to be included&#125;&#10;    end &#123;getch&#125;&#10;begin&#10;while ch=&#39; &#39; do getch;&#123;function_1: neglect space&#125;&#10;case&#10;&#123;code to be included&#125;&#10;end &#123;getsym&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>procedure getch</code>的过程如下：<br><img src="http://ww4.sinaimg.cn/large/a656b2e0gw1ethzx6qrr6j20by0d575h.jpg" alt="getch"></p>
<h4 id="getsym完成后的表达式识别部分（语法分析）">getsym完成后的表达式识别部分（语法分析）</h4><p>语法分析流程图：<br><img src="http://ww1.sinaimg.cn/large/a656b2e0gw1ethzxpbc4zj20by0g2ace.jpg" alt="语法分析流程图"></p>
<h5 id="表达式的EBNF">表达式的EBNF</h5><p>〈表达式〉∷=[+|-]〈项〉{（+|-）〈项〉}<br>〈项〉∷=〈因子〉{（*|/）〈因子〉}<br>〈因子〉∷=〈标识符〉|〈无符号整数〉|‘（’〈表达式〉‘）’ </p>
<h5 id="〈表达式〉的递归子程序实现">〈表达式〉的递归子程序实现</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procedure expr;&#10;&#12288;&#12288;&#12288;begin&#10;&#12288;&#12288;&#12288;&#12288;if sym in [ plus, minus ] then&#10;&#12288;&#12288;&#12288;&#12288;&#12288;begin&#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;getsym; term; &#10;&#12288;&#12288;&#12288;&#12288;&#12288;end&#10;&#12288;&#12288;&#12288;&#12288;else term;&#10;&#12288;&#12288;&#12288;&#12288;while sym in [plus, minus] do&#10;&#12288;&#12288;&#12288;&#12288;&#12288;begin&#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;getsym; term;&#10;&#12288;&#12288;&#12288;&#12288;&#12288;end&#10;&#12288;&#12288;&#12288;end;</span><br></pre></td></tr></table></figure>
<h5 id="〈项〉的递归子程序实现">〈项〉的递归子程序实现</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procedure term;&#10;&#12288;&#12288;begin&#10;&#12288;&#12288;&#12288;factor;&#10;&#12288;&#12288;&#12288;while sym in [ times, slash ] do&#10;&#12288;&#12288;&#12288;begin&#10;&#12288;&#12288;&#12288;&#12288;getsym; factor;&#10;&#12288;&#12288;&#12288;end&#10;&#12288;&#12288;end;</span><br></pre></td></tr></table></figure>
<h5 id="〈因子〉的递归子程序实现">〈因子〉的递归子程序实现</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procedure factor;&#10;&#12288;&#12288;begin &#10;&#12288;&#12288;&#12288;if sym &#60;&#62; ident then&#10;&#12288;&#12288;&#12288;&#12288;begin&#10;&#12288;&#12288;&#12288;&#12288;&#12288;if sym &#60;&#62; number then&#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;begin&#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;if sym = &#8216;(&#8216; then&#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;begin&#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;getsym;&#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;expr;&#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;if sym = &#8216;)&#8217; then &#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;getsym&#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;else error&#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;end&#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;else error&#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;end&#10;&#12288;&#12288;&#12288;&#12288;end&#10;&#12288;&#12288;end;</span><br></pre></td></tr></table></figure>
<h4 id="语法与语义分析（block部分/重点）">语法与语义分析（block部分/重点）</h4><h5 id="对变量定义的语法处理">对变量定义的语法处理</h5><p>语法：&lt;变量说明部分&gt;: := var &lt;标识符&gt;{， &lt;标识符&gt;}；<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if sym=varsym then&#10;&#12288;begin&#10;&#12288;&#12288;getsym;&#10;&#12288;&#12288;repeat&#10;&#12288;&#12288;&#12288;vardeclaration;(*&#21464;&#37327;&#35828;&#26126;&#22788;&#29702;*) &#10;&#12288;&#12288;&#12288;while sym=comma do&#10;&#12288;&#12288;&#12288;&#12288;begin&#10;&#12288;&#12288;&#12288;&#12288;&#12288;getsym;&#10;&#12288;&#12288;&#12288;&#12288;&#12288;vardeclaration&#10;&#12288;&#12288;&#12288;&#12288;end;&#10;&#12288;&#12288;&#12288;if sym=semicolon then&#10;&#12288;&#12288;&#12288;&#12288;getsym&#10;&#12288;&#12288;&#12288;else error(5)&#10;&#12288;&#12288;until sym&#60;&#62;ident;&#10;&#12288;end;</span><br></pre></td></tr></table></figure></p>
<p>CODE in PASCAL<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Procedure vardeclaration;&#10;&#12288;begin&#10;&#12288;&#12288;if sym = ident then&#10;&#12288;&#12288;&#12288;begin&#10;&#12288;&#12288;&#12288;&#12288;enter(variable);( *&#35843;&#29992;&#36807;&#31243;enter&#36896;&#21517;&#23383;&#34920;*&#65289;&#10;&#12288;&#12288;&#12288;&#12288;getsym&#10;&#12288;&#12288;&#12288;end&#10;&#12288;&#12288;else error(4)&#10;&#12288;end(*vardeclaration*);</span><br></pre></td></tr></table></figure></p>
<p><code>procedure enter</code>的实现<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procedure enter(k:object );&#10;&#12288;begin (* enter object into table *)&#10;&#12288;&#12288;tx:=tx+1;&#10;&#12288;&#12288;with table[tx] do (* &#24320;&#22495;&#35821;&#21477; *&#65289;&#10;&#12288;&#12288;begin&#10;&#12288;&#12288;&#12288;name:=id;(* &#34920;&#31034;table[tx].name:=id;&#21517;&#23383;&#35760;&#24405;&#22312;table&#34920;&#20013; *&#65289; &#10;&#12288;&#12288;&#12288;kind:=k;(* &#34920;&#31034;table[tx].kind:=k;&#31867;&#22411;&#35760;&#24405;&#22312;table&#34920;&#20013; * )&#10;&#12288;&#12288;&#12288;case k of&#10;&#12288;&#12288;&#12288;constant: &#10;&#12288;&#12288;&#12288;&#12288;begin&#10;&#12288;&#12288;&#12288;&#12288;&#12288;if num&#62;amax then&#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;begin&#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;error(31);&#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;num:=0;&#10;&#12288;&#12288;&#12288;&#12288;&#12288;&#12288;end;&#10;&#12288;&#12288;&#12288;&#12288;&#12288;val:=num;(* table[tx].val:=num;&#24120;&#37327;&#30340;&#20540;&#35760;&#24405;&#22312;table&#34920;&#20013; *)&#10;&#12288;&#12288;&#12288;&#12288;end;&#10;&#12288;&#12288;variable: &#10;&#12288;&#12288;&#12288;begin&#10;&#12288;&#12288;&#12288;&#12288;level:=lev;&#65288;*&#34920;&#31034;table[tx].level:=lev&#21464;&#37327;&#23450;&#20041;&#30340;&#25152;&#22312;&#23618;&#27425;&#35760;&#24405; &#22312;table&#34920;&#20013; *&#65289; &#10;&#12288;&#12288;&#12288;&#12288;adr:=dx;&#65288;*&#34920;&#31034;table[tx].adr:=dx&#32473;&#21464;&#37327;&#20998;&#37197;&#30340;&#20301;&#32622;&#35760;&#24405;&#22312;table&#34920;&#20013; *&#65289; &#10;&#12288;&#12288;&#12288;&#12288;dx:=dx+1;&#65288;*&#32473;&#21464;&#37327;&#20998;&#37197;&#20301;&#32622;&#30340;&#25351;&#31034;&#22120;&#21152;1&#65292;&#25351;&#21521;&#19979;&#19968;&#20010;&#21464;&#37327;&#30340;&#20301;&#32622;*&#65289;&#10;&#12288;&#12288;&#12288;end;&#10;&#12288;&#12288;procedur: level:=lev&#65307;&#10;&#12288;&#12288;&#12288;(* &#34920;&#31034;table[tx].level:=lev;&#36807;&#31243;&#23450;&#20041;&#30340;&#25152;&#22312;&#23618;&#27425;&#35760;&#24405;&#22312;table&#34920;&#20013; *&#65289;&#10;&#12288;&#12288;end(* case *); &#10;&#12288;end&#10;end(*enter*);</span><br></pre></td></tr></table></figure></p>
<p>TABLE表的信息包括：NAME，KIND，LEVEL/VAL，ADR和SIZE。<br>TABLE信息表的示例：<br><img src="http://ww2.sinaimg.cn/large/a656b2e0gw1eti00cj1xmj20by07a0tw.jpg" alt="TABLE信息表"></p>
<h5 id="过程部分处理">过程部分处理</h5><p>程序的主体是由语句构成的。处理完过程的说明后就处理由语句组成的过程体，从语法上要对语句逐句分析。当语法正确时就生成相应语句功能的目标代码。当遇到标识符的引用时就调用POSITION函数查TABLE表，看是否有过正确的定义，若已有，则从表中取相应的有关信息，供代码的生成用。若无定义则出错。</p>
<p>BLOCK对分程序的处理<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">begin (*block*)&#10;&#12288;&#12288;&#12288;dx:=3;&#10;&#12288;&#12288;&#12288;tx0:=tx; &#65288;*&#20445;&#30041;&#24403;&#21069;table&#34920;&#25351;&#38024;&#20540;,&#23454;&#38469;&#20026;&#36807;&#31243;&#21517;&#22312;table&#34920;&#20013;&#30340;&#20301;&#32622;*&#65289;&#10;&#12288;&#12288;&#12288;table[tx].adr:=cx;&#65288;*&#20445;&#30041;&#24403;&#21069;code&#25351;&#38024;&#20540;&#21040;&#36807;&#31243;&#21517;&#30340;adr&#22495;*&#65289;&#10;&#12288;&#12288;&#12288;gen(jmp,0,0);</span><br></pre></td></tr></table></figure></p>
<h4 id="目标代码生成">目标代码生成</h4><ul>
<li>PL/0语言的代码生成是由过程GEN完成的。<br>GEN过程有三个参数，分别代表目标代码的功能码、层差和位移量(对不同的指令含意不同)。</li>
<li>生成的代码顺序放在数组CODE中。<br>CODE为一维数组，数组元素为记录型数据。每一个记录就是一条目标指令。</li>
<li>CX为指令的指针，由0开始顺序增加。</li>
<li>实际上目标代码的顺序是内层过程的排在前边，主程序的目标代码在最后。</li>
</ul>
<h4 id="出错处理">出错处理</h4><p>FSYS为被调用的语法分析程序开始符号合法的后继单词符号集合，FSYS示例如下<br><img src="http://ww4.sinaimg.cn/large/a656b2e0gw1ethzyg0f38j20mn08emyr.jpg" alt="FSYS示例"></p>
<ul>
<li>在进入某个语法单位时，调用TEST,检查当前符号是否属于该语法单位的开始符号集合。若不属于，则滤去开始符号和后继符号集合外的所有符号。</li>
<li>在语法单位分析结束时，调用TEST,检查当前符号是否属于调用该语法单位时应有的后继符号集合。若不属于，则滤去后继符号和开始符号集合外的所有符号。</li>
</ul>
<h5 id="PL/0出错信息表">PL/0出错信息表</h5><p>出错编号    出错原因<br>1：        常数说明中的”=”写成”∶=”。<br>2：        常数说明中的”=”后应是数字。<br>3：        常数说明中的标识符后应是”=”。<br>4：        const ,var, procedure后应为标识符。<br>5：        漏掉了’，’或’；’。<br>6：        过程说明后的符号不正确(应是语句开始符，或过程定义符)。<br>7：        应是语句开始符。<br>8：        程序体内语句部分的后跟符不正确。<br>9：        程序结尾丢了句号’.’。<br>10：   语句之间漏了’；’。<br>11：     标识符未说明。<br>12：   赋值语句中，赋值号左部标识符属性应是变量。<br>13：   赋值语句左部标识符后应是赋值号’∶=’。<br>14：   call后应为标识符。<br>15：   call后标识符属性应为过程。<br>16：   条件语句中丢了’then’。<br>17：   丢了’end”或’；’。<br>18：   while型循环语句中丢了’do’。<br>19：   语句后的符号不正确。<br>20：   应为关系运算符。<br>21：   表达式内标识符属性不能是过程。<br>22：   表达式中漏掉右括号’)’。<br>23：   因子后的非法符号。<br>24：   表达式的开始符不能是此符号。<br>31：   数越界。<br>32：   read语句括号中的标识符不是变量。</p>
<h4 id="解释程序">解释程序</h4><p>解释程序还定义了4个寄存器。<br>　　(1) I：指令寄存器。存放着当前正在解释的一条目标指令。<br>　　(2) P：程序地址寄存器。指向下一条要执行的目标程序的地址(相当目标程序CODE数组的下标)。<br>　　(3) T：栈顶寄存器。由于每个过程当它被运行时，给它分配的数据空间(下边称数据段)可分成两部分。<br>　　静态部分：包括变量存放区和三个联系单元(联系单元的作用见后)。<br>　　动态部分：作为临时工作单元和累加器用。需要时随时分配，用完后立即释放。栈顶寄存器T指出了当前栈中最新分配的单元(T也是数组S的下标)。<br>　　(4) B：基址寄存器。指向每个过程被调用时，在数据区S中给它分配的数据段起始地址，也称基地址。<br>　　为了实现对每个过程调用时给它分配数据段，也就是对即将运行的过程所需数据段进栈；过程运行结束后释放数据段，即该数据段退栈；以及嵌套过程之间对标识符引用的寻址问题。每个过程被调用时，在栈顶分配三个联系单元，这三个单元存放的内容分别为：<br>　　(1) SL：静态链：它是指向定义该过程的直接外过程(或主程序)运行时最新数据段的基地址。<br>　　(2) DL：动态链：它是指向调用该过程时正在运行过程的数据段基地址。<br>　　(3) RA：返回地址：记录调用该过程时目标程序的断点，即当时的程序地址寄存器P的值。也就是调用过程指令的下一条指令的地址。</p>
<h4 id="增加部分">增加部分</h4><h5 id="case语句">case语句</h5><p>第一步：记录表达式的标记，处理表达式，标记常量的入口位置。<br>第二步：每次将表达式的值与常量进行比较，形成跳转指令，执行完一条语句之后产生无条件跳转指令。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procedure casestatement;   &#123;case&#125;&#10;         var x:item;&#10;             coni,conj:integer;  &#10;         begin&#10;                getsym;cx1:=cx;&#10;                expression([ofsym]+fsys,x);cx2:=cx;&#10;              if (x.typ = ints) or (x.typ = chars)then &#10;               begin&#10;                if sym=ofsym then&#10;                begin&#10;                 getsym;conj:=0;&#10;                 while sym&#60;&#62;elsesym do &#10;                 begin&#10;                     if (sym = intcon) or (sym = charcon) then&#10;                     begin&#10;                    coni:=cx1;&#10;                      if conj&#60;&#62;0 then&#10;                      begin&#10;                      while coni&#60;cx2 do&#10;                      begin&#10;                        code[cx]:=code[coni];&#10;                         cx:=cx+&#10;                         coni:=coni+1;&#10;                      end&#10;                      end;&#10;                      conj:=1;&#10;                      gen(lit,0,num);&#10;                      coni:=cx1;&#10;                      end&#10;                      else error(12);&#10;                      getsym;&#10;                       if sym=colon then&#10;                       begin&#10;                          getsym;&#10;                          gen(eq,0,0);&#10;                          cx2:=cx;&#10;                            gen(jpc,0,0);&#10;                            statement([semicolon]+fsys);&#10;                       if sym=semicolon then&#10;                       begin&#10;                        getsym;&#10;                        labtab[lx]:=cx;lx:=lx+1;&#10;                        gen(jmp,0,0);&#10;                        code[cx2].a:=cx&#10;                         end&#10;                       else error(23)&#10;                      end&#10;                      else  error(24)&#123;colon&#125;&#10;                     end;&#10;                   if sym=elsesym then&#10;                     begin&#10;                        getsym;&#10;                    statement([endsym]+fsys);&#10;                        lx:=lx-1;&#10;                         while lx&#62;=0 do&#10;                         begin code[labtab[lx]].a:=cx;&#10;                        lx:=lx-1&#10;                         end&#10;                  end;&#10;                  if sym=endsym then getsym&#10;                  else error(36)&#10;              end&#10;              else error(17)&#10;             end&#10;          end;</span><br></pre></td></tr></table></figure></p>
<h5 id="repeat语句">repeat语句</h5><p>在第一条语句前记录标记，处理完语句之后，判断布尔表达式的值，并产生跳转指令。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procedure repeatstatement;&#123;repeat&#125;&#10;var x:item;&#10;begin&#10;  getsym;cx1:=cx; labtab[lx]:=cx;lx:=lx+1;&#10;  statement([untilsym]+fsys);&#10;  if sym&#60;&#62;semicolon then error(23);&#10;  getsym;&#10;  while (not (sym in ([untilsym]))) do&#10;    begin&#10;     statement([untilsym]+fsys);&#10;     if sym&#60;&#62;semicolon then error(23);&#10;     getsym&#10;    end;&#10;    &#10;  if sym=untilsym then &#10;    begin&#10;      getsym;&#10;      expression([endsym]+fsys,x);&#10;      if x.typ &#60;&#62; bool then error(34); &#10;      gen(jpc,0,cx1);labtab[lx]:=cx;lx:=lx+1&#10;    end&#10;end;</span><br></pre></td></tr></table></figure></p>
<h5 id="for语句">for语句</h5><p>第一步：通过词法扫描，先处理控制变量，将其装入符号表，读入初值之后存入控制变量对应的地址中。<br>第二步：读入终止值，每次判断是否满足条件，记录语句的标号，之后进入语句，处理完之后，将控制变量加一，并判断是否跳转。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procedure forstatement;&#123;for&#125;&#10;begin&#10;     getsym;&#10;     if sym=ident then&#10;     begin &#10;             i:=position(id);getsym;&#10;             if i=0 then error(10)&#10;             else&#10;                  if nametab[i].kind&#60;&#62;variable then&#10;                     begin&#10;                     error(30);i:=0&#10;                     end &#10;                  else&#10;                     begin&#10;                        x.typ:=nametab[i].typ;&#10;            x.ref:=nametab[i].ref; &#10;            if nametab[i].normal  &#10;            then gen(loda,nametab[i].lev,nametab[i].adr)&#10;            else gen(lod,nametab[i].lev,nametab[i].adr)&#10;           end;&#10;       if sym=becomes then &#10;       begin&#10;           getsym;&#10;           expression([tosym]+fsys,ini);&#10;             if  ini.typ&#60;&#62;ints then error(12)&#10;             else begin&#10;                     gen(sto,0,0);&#10;                     if sym=tosym then&#10;                         begin&#10;                            getsym;cx1:=cx;labtab[lx]:=cx;lx:=lx+1;&#10;                            gen(loda,nametab[i].lev,nametab[i].adr);&#10;                            gen(lodt,0,0);&#10;                            expression([dosym]+fsys,fin);&#10;                          if sym=dosym then&#10;                               begin&#10;                                 gen(le,0,0);&#10;                                 cx2:=cx;labtab[lx]:=cx;lx:=lx+1;&#10;                                 gen(jpc,0,0);&#10;                                     getsym;&#10;                                   statement(fsys);&#10;                                     if nametab[i].normal then&#10;                                     begin&#10;                                         gen(loda,nametab[i].lev,nametab[i].adr);&#10;                                         gen(loda,nametab[i].lev,nametab[i].adr);&#10;                                   gen(lodt,0,0)&#10;                                     end&#10;                                     else gen(lod,nametab[i].lev,nametab[i].adr);&#10;                                     gen(lit,0,1);&#10;                                     gen(add,0,0);&#10;                         gen(sto,0,0);&#10;                         gen(jmp,0,cx1);&#10;                         code[cx2].a:=cx&#10;                                 end&#10;                         end&#10;                      end&#10;       end&#10;   end&#10;   else error(33)&#10;end;</span><br></pre></td></tr></table></figure></p>
<h4 id="完整程序">完整程序</h4><h5 id="程序结构分析">程序结构分析</h5><table>
<thead>
<tr>
<th style="text-align:left">过程或函数名</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">语句</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">plcompiler</td>
<td style="text-align:left">主程序</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">error</td>
<td style="text-align:left">出错处理</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">getsym</td>
<td style="text-align:left">词法分析，读取一个单词</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">getch</td>
<td style="text-align:left">读取一个字符（忽略空格）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">gen</td>
<td style="text-align:left">目标代码生成</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">test</td>
<td style="text-align:left">测试语句合法性</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">block</td>
<td style="text-align:left">分程序处理</td>
<td style="text-align:left">包含语法分析</td>
</tr>
<tr>
<td style="text-align:left">enter</td>
<td style="text-align:left">登陆名字表</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">position</td>
<td style="text-align:left">查找标识符在名字表中的位置</td>
<td style="text-align:left">position(id:alfa):integer</td>
</tr>
<tr>
<td style="text-align:left">constdeclaration</td>
<td style="text-align:left">常量定义处理</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">vardeclaration</td>
<td style="text-align:left">变量说明处理</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">statement</td>
<td style="text-align:left">语句部分处理</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">listcode</td>
<td style="text-align:left">列出目标代码清单</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">expression</td>
<td style="text-align:left">表达式处理</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">term</td>
<td style="text-align:left">项处理</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">factor</td>
<td style="text-align:left">因子处理</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">condition</td>
<td style="text-align:left">条件处理</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">interpret</td>
<td style="text-align:left">对目标代码的解释执行程序</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">base</td>
<td style="text-align:left">通过静态链求出数据区的基地址</td>
<td style="text-align:left">未包含在代码中？</td>
</tr>
</tbody>
</table>
<p> PL/0编译程序过程与函数定义层次结构图<br> <img src="http://ww1.sinaimg.cn/large/a656b2e0gw1eti01mz3w0j207y0cnjru.jpg" alt=" PL/0编译程序过程与函数定义层次结构图"></p>
<p>PL/0编译程序总体流程图<br><img src="http://ww1.sinaimg.cn/large/a656b2e0gw1ethzz42xnkj20by0f7q4a.jpg" alt="PL/0编译程序总体流程图"></p>
<h5 id="CODE">CODE</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">program plcopiler;&#10;uses dos;&#10;const norw=25;       &#123; no. of reserved words &#125;&#10;      txmax=100;     &#123; length of identifier table &#125;&#10;      bmax=25;       &#123; length of block inormation table &#125;&#10;      arrmax=30;     &#123; length of array information table &#125;&#10;      nmax=6;        &#123; max. no. of digits in numbers &#125;&#10;      al=10;         &#123; length of identifiers &#125;&#10;      amax=2047;     &#123; maxinum address &#125;&#10;      levmax=7;      &#123; maxinum depth of block nesting &#125;&#10;      cxmax=1000;    &#123; size of code array &#125;&#10;&#10;type symbol=&#10;     (nul,ident,intcon,charcon,plus,minus,times,divsym,&#10;      eql,neq,lss,leq,gtr,geq, ofsym,arraysym,programsym,modsym,&#10;      andsym,orsym,notsym,lbrack,rbrack,lparen,rparen,comma,&#10;      semicolon,period,becomes,colon,beginsym,endsym,ifsym,casesym,thensym,&#10;      elsesym,whilesym,repeatsym,dosym,callsym,constsym,typesym,&#10;      varsym,procsym,forsym,untilsym,functionsym,tosym);&#10;     alfa = string[al];&#10;     index=-32767..+32767;&#10;     oobject = (konstant,typel,variable,prosedure);&#10;     types=(notyp,ints,chars,bool,arrays);&#10;     symset = set of symbol;&#10;&#10;     opcod = (lit,lod,ilod,loda,lodt,sto,lodb,cpyb,jmp,jpc,red,wrt,&#10;            cal,retp,endp,udis,opac,entp,ands,ors,nots,imod,mus,add,&#10;            sub,mult,idiv,eq,ne,ls,le,gt,ge);  &#123; opration code &#125;&#10;     instruction = packed record&#10;                     f:opcod;&#10;                     l:0..levmax;&#10;                     a:0..amax;&#10;                   end;&#10;     item=record&#10;             typ:types;&#10;             ref:integer&#10;           end;&#10;&#10;var ch:char;           &#123; last character read &#125;&#10;    sym:symbol;        &#123; last symbol read&#125;&#10;    id:alfa;           &#123; last identifier read  10&#125; &#10;    num:integer;       &#123; last number read &#125;&#10;    cc:integer;        &#123; character count &#125;&#10;    ll:integer;        &#123; line length &#125;&#10;    kk,err:integer;&#10;    line:string[81];&#10;    a:alfa;&#10;    i:integer;&#10;    word:array[1..norw] of alfa;&#10;    wsym:array[1..norw] of symbol;&#10;    ssym:array[char] of symbol;&#10;    mnemonic:array[opcod] of string[5];&#10;    declbegsys,statbegsys,facbegsys,constbegsys,typebegsys:symset;&#10;&#10;    nametab:array[0..txmax] of          &#123; name table &#125;&#10;               record&#10;                 name:alfa;&#10;                 kind:&#10;                 oobject ;&#10;                 typ: types;&#10;                 lev: 0..levmax;&#10;                 normal:boolean;&#10;                 ref:index;&#10;                 link:index;&#10;                 case oobject of&#10;                   variable,prosedure:(adr:integer);&#10;                   konstant         :(val:integer);&#10;                   typel            :(size:integer);&#10;&#10;               end;&#10;    tx:  integer;           &#123; index of nametab&#125;&#10;&#10;&#10;    atab:array[1..amax] of             &#123; array information table &#125;&#10;              record&#10;                inxtyp,eltyp:types;&#10;                elref,low,high,elsize,size:index;&#10;              end;&#10;    ax:integer;             &#123;index of atab &#125;&#10;&#10;    btab:array[0..bmax] of            &#123; block information table &#125;&#10;              record&#10;                last,lastpar,psize,vsize:index;&#10;              end;&#10;    bx:integer;                 &#123; index of btab &#125;&#10;    display:array[0..levmax] of integer;&#10;&#10;&#10;    code:array[0..cxmax] of instruction;&#10;    cx:integer;          &#123; code allocation index &#125;&#10;&#10;    labtab:array[0..100] of integer;&#10;    lx:integer;&#10;&#123;********************************************************&#125;&#10;   &#10;   &#10;    sfile:text;         &#123; source program file &#125;&#10;    sfilename:string; &#123; source program file name &#125;&#10;    fcode:file of instruction;&#10;    labfile:file of integer;&#10;&#10;    listfile :text;&#10;    listfilename:string;&#10;    dir:dirstr;&#10;    name:namestr;&#10;    ext:extstr;&#10;&#123;*********************************************************&#125;&#10;&#10;procedure initial;&#10; begin&#10;word[ 1]:=&#39;and       &#39;; &#10;  word[ 2]:=&#39;array     &#39;;&#10;  word[ 3]:=&#39;begin     &#39;; &#10;  word[ 4]:=&#39;call      &#39;;&#10;  word[ 5]:=&#39;case      &#39;;&#10;  word[ 6]:=&#39;const     &#39;; &#10;  word[ 7]:=&#39;do        &#39;;&#10;  word[ 8]:=&#39;else      &#39;; &#10;  word[ 9]:=&#39;end       &#39;;&#10;  word[10]:=&#39;for       &#39;; &#10;  word[11]:=&#39;function  &#39;; &#10;  word[12]:=&#39;if        &#39;; &#10;  word[13]:=&#39;mod       &#39;;&#10;  word[14]:=&#39;not       &#39;; &#10;  word[15]:=&#39;of        &#39;;&#10;  word[16]:=&#39;or        &#39;; &#10;  word[17]:=&#39;procedure &#39;;&#10;  word[18]:=&#39;program   &#39;; &#10;  word[19]:=&#39;repeat    &#39;;&#10;  word[20]:=&#39;then      &#39;;&#10;  word[21]:=&#39;to        &#39;;&#10;  word[22]:=&#39;type      &#39;;&#10;  word[23]:=&#39;until     &#39;;&#10;  word[24]:=&#39;var       &#39;; &#10;  word[25]:=&#39;while     &#39;;&#10;  wsym[ 1]:=andsym;       &#10;  wsym[ 2]:=arraysym;&#10;  wsym[ 3]:=beginsym;     &#10;  wsym[ 4]:=callsym;&#10;  wsym[ 5]:=casesym;     &#10;  wsym[ 6]:=constsym;&#10;  wsym[ 7]:=dosym;      &#10;  wsym[ 8]:=elsesym;&#10;  wsym[ 9]:=endsym;        &#10;  wsym[10]:=forsym;&#10;  wsym[11]:=functionsym;     &#10;  wsym[12]:=ifsym;&#10;  wsym[13]:=modsym;        &#10;  wsym[14]:=notsym;&#10;  wsym[15]:=ofsym;   &#10;  wsym[16]:=orsym;&#10;  wsym[17]:=procsym;      &#10;  wsym[18]:=programsym;&#10;  wsym[19]:=repeatsym;       &#10;  wsym[20]:=thensym;&#10;  wsym[21]:=tosym;&#10;  wsym[22]:=typesym;       &#10;  wsym[23]:=untilsym;  &#10;  wsym[24]:=varsym;       &#10;  wsym[25]:=whilesym;      &#10;  &#10;  ssym[&#39;+&#39;]:=plus;        ssym[&#39;-&#39;]:=minus;&#10;  ssym[&#39;*&#39;]:=times;       ssym[&#39;/&#39;]:=divsym;&#10;  ssym[&#39;[&#39;]:=lbrack;      ssym[&#39;]&#39;]:=rbrack;&#10;  ssym[&#39;(&#39;]:=lparen;      ssym[&#39;)&#39;]:=rparen;&#10;  ssym[&#39;=&#39;]:=eql;         ssym[&#39;,&#39;]:=comma;&#10;  ssym[&#39;.&#39;]:=period;&#10;  ssym[&#39;&#60;&#39;]:=lss;         ssym[&#39;&#62;&#39;]:=gtr;&#10;  ssym[&#39;;&#39;]:=semicolon;&#10;&#10;  mnemonic[lit]:=&#39;LIT  &#39;;   mnemonic[lod]:=&#39;LOD  &#39;;&#10;  mnemonic[sto]:=&#39;STO  &#39;;   mnemonic[cal]:=&#39;CAL  &#39;;&#10;  mnemonic[jmp]:=&#39;JMP  &#39;;   mnemonic[jpc]:=&#39;JPC  &#39;;&#10;  mnemonic[red]:=&#39;RED  &#39;;   mnemonic[wrt]:=&#39;WRT  &#39;;&#10;  mnemonic[ilod]:=&#39;ILOD  &#39;; mnemonic[loda]:=&#39;LODA &#39;;&#10;  mnemonic[lodt]:=&#39;LODt  &#39;; mnemonic[lodb]:=&#39;LODB &#39;;&#10;  mnemonic[cpyb]:=&#39;COPYB &#39;; mnemonic[endp]:=&#39;ENDP &#39;;&#10;  mnemonic[retp]:=&#39;RETP  &#39;; mnemonic[udis]:=&#39;ADIS &#39;;&#10;  mnemonic[mus]:=&#39;MUS  &#39;;   mnemonic[add]:=&#39;ADD &#39;;&#10;  mnemonic[sub]:=&#39;SUB  &#39;;   mnemonic[mult]:=&#39;MULT &#39;;&#10;  mnemonic[idiv]:=&#39;DDIV  &#39;; mnemonic[eq]:=&#39;EQ  &#39;;&#10;  mnemonic[ne]:=&#39;NE &#39;;      mnemonic[ls]:=&#39;LS  &#39;;&#10;  mnemonic[le]:=&#39;LE &#39;;      mnemonic[gt]:=&#39;GT  &#39;;&#10;  mnemonic[ge]:=&#39;GE &#39;;      mnemonic[opac]:=&#39;OPAC &#39;;&#10;  mnemonic[entp]:=&#39;ENTP&#39;;   mnemonic[imod]:=&#39;IMOD &#39;;&#10;  mnemonic[ands]:=&#39;ANDS&#39;;   mnemonic[ors]:=&#39;ORS &#39;;&#10;  mnemonic[nots]:=&#39;NOTS&#39;;&#10;&#10;  declbegsys:=[constsym,varsym,typesym,procsym];   &#10;  statbegsys:=[beginsym,callsym,ifsym,whilesym,casesym,repeatsym,untilsym,forsym];      &#10;  facbegsys :=[ident,intcon,lparen,notsym,charcon];&#10;  typebegsys:=[ident,arraysym];&#10;  constbegsys:=[plus,minus,intcon,charcon,ident];&#10;  err:=0; a[0]:=#10;&#10;  display[0]:=0;   &#10;  cc:=0; cx:=0; ll:=0; ch:=&#39; &#39;; kk:=al; bx:=1;  tx:=-1;&#10;  lx:=0&#10; end;   &#123;init&#125;&#10;&#10; procedure enterpreid;                              &#10;   procedure enter(x0:alfa;x1:oobject;&#10;                  x2:types;x3:integer);&#10;   begin&#10;    tx:=tx+1;&#10;    with nametab[tx] do&#10;    begin&#10;      name:=x0;link:=tx-1;kind:=x1;&#10;      typ:=x2;ref:=0;normal:=true;&#10;      lev:=0;&#10;      case kind of&#10;        variable,prosedure: adr:=x3;       &#10;        konstant:           val:=x3;                &#10;        typel:              size:=x3                    &#10;      end&#10;    end&#10;   end;&#10;  begin&#10;   enter(&#39;          &#39;,variable,notyp,0);       &#123; sentinel &#125;&#10;   enter(&#39;char      &#39;,typel, chars,1);    &#10;   enter(&#39;integer   &#39;,typel,ints,  1);&#10;   enter(&#39;boolean   &#39;,typel,bool,  1);&#10;   enter(&#39;false     &#39;,konstant,bool,  0);&#10;   enter(&#39;true      &#39;,konstant,bool,  1);&#10;   enter(&#39;read      &#39;,prosedure,notyp,1);&#10;   enter(&#39;write     &#39;,prosedure,notyp,2);&#10;   btab[0].last:=tx; btab[0].lastpar:=1;&#10;   btab[0].psize:=0; btab[0].vsize:=0&#10;  end;       &#123;enterprid&#125;&#10;&#10; procedure error(n:integer);&#10;   begin writeln(listfile,&#39;****&#39;,&#39; &#39;:cc-1,&#39;^&#39;,n:2);&#10;        err:=err+1&#10;   end; &#123; error &#125;&#10;&#10;&#10; procedure getsym;&#10;    label 1;&#10;    var i,k,j:integer;&#10;    procedure getch;&#10;    begin&#10;      if cc=ll then   &#123; get character to end of line &#125;&#10;      &#123; read next line &#125;&#10;      begin&#10;        if eof(sfile) then  &#10;          begin&#10;            writeln(&#39;program incomplete&#39;);&#10;            close(sfile);&#10;            exit;&#10;          end;&#10;        ll:=0; cc:=0; write(listfile,cx:4,&#39; &#39;);    &#123;print code address &#125;&#10;        while not eoln(sfile) do&#10;          begin&#10;            ll:=ll+1; read(sfile,ch); write(listfile,ch);&#10;            line[ll]:=ch&#10;          end;&#10;        writeln(listfile); readln(sfile);&#10;        ll:=ll+1; line[ll]:=&#39; &#39;  &#123;process end-line&#125;           &#10;      end;&#10;      cc:=cc+1; ch:=line[cc]           &#10;    end;  &#123; getch &#125;&#10;  begin  &#123;getsym&#125;&#10; 1:   while ch=&#39; &#39; do getch;&#10;    case ch of&#10;    &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;,&#39;n&#39;,&#10;    &#39;o&#39;,&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;:&#10;    begin   &#123; identifier or reserved&#65288;&#20851;&#38190;&#23383;&#65289; word &#125;&#10;      k:=0;&#10;      repeat&#10;        if k&#60;al then&#10;          begin k:=k+1; a[k]:=ch  end;&#10;        getch&#10;      until not (ch in [&#39;a&#39;..&#39;z&#39;,&#39;0&#39;..&#39;9&#39;]);&#10;      if k&#62;=kk then kk:=k      &#123; kk: last identifier length &#125;&#10;      else&#10;        repeat&#10;          a[kk]:=&#39; &#39;; kk:=kk-1&#10;        until kk=k;&#10;      id:=a; i:=1; j:=norw; &#123; binary search reserved word table &#125;&#10;      repeat&#10;        k:=(i+j) div 2;&#10;        if id&#60;=word[k] then j:=k-1;&#10;        if id&#62;=word[k] then i:=k+1;&#10;      until i&#62;j;&#10;      if i-1&#62;j then sym:=wsym[k]&#10;      else sym:=ident&#10;    end;&#10;    &#10;    &#39;&#123;&#39; :&#10;    begin&#10;      repeat&#10;         getch&#10;      until ch = &#39;&#125;&#39;;&#10;       getch;&#10;      goto 1&#10;    end;&#10;    &#10;    &#10; &#10;    &#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;:&#10;      begin &#123; number &#125;&#10;        k:=0; num:=0; sym:=intcon;&#10;        repeat&#10;          num:=10*num+(ord(ch)-ord(&#39;0&#39;));&#10;          k:=k+1; getch&#10;        until not (ch in [&#39;0&#39;..&#39;9&#39;]);&#10;        if k&#62;nmax then error(47)&#10;      end;&#10;      &#10;   &#39;:&#39;:&#10;        begin&#10;          getch;&#10;          if ch=&#39;=&#39; then&#10;            begin sym:=becomes; getch end&#10;          else sym:=colon&#10;        end ;&#10;   &#39;&#60;&#39; :&#10;        begin&#10;            getch;&#10;            if ch=&#39;=&#39; then&#10;              begin sym:=leq; getch end&#10;            else&#10;              if ch=&#39;&#62;&#39; then&#10;                begin sym:=neq; getch end&#10;              else sym:=lss&#10;          end ;&#10;   &#39;&#62;&#39; :&#10;        begin&#10;              getch;&#10;              if ch=&#39;=&#39; then&#10;                begin sym:=geq; getch end&#10;              else sym:=gtr&#10;        end  ;&#10;   &#39;.&#39; :&#10;        begin&#10;          getch;&#10;          if ch=&#39;.&#39;&#10;            then  begin&#10;                   sym:=colon;getch&#10;                  end&#10;            else   sym:=period&#10;         end;&#10;   &#39;&#39;&#39;&#39;  :&#10;        begin&#10;          getch;&#10;          sym:=charcon;num:=ord(ch);&#10;          getch;&#10;          if ch=&#39;&#39;&#39;&#39; then getch&#10;                     else error(48)&#10;        end;&#10;   &#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&#39;/&#39;,&#39;(&#39;,&#39;)&#39;,&#39;=&#39;,&#39;[&#39;,&#39;]&#39;,&#39;;&#39;,&#39;,&#39;:&#10;        begin&#10;          sym:=ssym[ch];getch&#10;        end;&#10;   else&#10;       begin&#10;         error(0); getch;&#10;         goto 1&#10;       end&#10;    end  &#123; case &#125;&#10;  end;  &#123; getsym &#125;    &#10;&#10;  procedure enterarray (tp:types ; l,h:integer); &#10;  begin&#10;    if l&#62;h then error(14);&#10;    if ax=amax then&#10;      begin&#10;        error(2);&#10;        writeln(&#39;too many arrays in program &#39;);&#10;        close(sfile);&#10;        close(listfile);&#10;        exit&#10;      end&#10;      else begin&#10;        ax:=ax+1;&#10;        with atab[ax] do&#10;        begin&#10;          inxtyp:=tp; low:=l; high:=h&#10;        end&#10;      end&#10;  end;  &#123; enterarray &#125;&#10;&#10;  procedure enterblock;   &#10;  begin&#10;    if bx=bmax  then&#10;      begin&#10;        error(3);&#10;        writeln(&#39;too many procedure in program &#39;);&#10;        close(sfile);&#10;        close(listfile);&#10;        exit&#10;      end&#10;    else begin&#10;      bx:=bx+1; btab[bx].last:=0; btab[bx].lastpar:=0&#10;    end&#10;  end;   &#123; enterblock &#125;&#10;&#10;  procedure gen(x:opcod; y,z:integer);  &#123;&#20135;&#29983;&#20195;&#30721;&#31243;&#24207;gen&#125;&#10;  begin&#10;    if cx&#62;cxmax then&#10;      begin&#10;        error(49);&#10;        writeln(&#39;program too long&#39;);&#10;        close(sfile);&#10;        close(listfile);&#10;        exit&#10;      end;&#10;    with code[cx] do&#10;      begin&#10;        f:=x; l:=y; a:=z    &#10;      end;&#10;     cx:=cx+1&#10;  end;  &#123; gen &#125;&#10;&#10;  procedure test(s1,s2:symset;n:integer);&#10;  begin&#10;    if not (sym in s1) then&#10;      begin&#10;        error(n); s1:=s1+s2;&#10;        while not (sym in s1) do getsym&#10;      end&#10;  end;  &#123; test &#125;&#10;&#10;  procedure block( fsys:symset;level:integer);&#10;  type&#10;    constrec=record   &#10;            tp:types;&#10;            i:integer&#10;           end;&#10;  var dx:integer;  &#123; data allocation index &#125;&#10;      tx0:integer; &#123; initial table index &#125;&#10;      cx0:integer; &#123; initial code  index &#125;&#10;      prt,prb:integer;&#10;  procedure enter( k:oobject);         &#10;   var j,l:integer;&#10;   begin&#10;     if tx=txmax&#10;      then  begin&#10;              error(1);&#10;              writeln(&#39;program too long&#39;);&#10;              close(sfile);&#10;              close(listfile);&#10;              exit&#10;            end&#10;      else  begin&#10;        nametab[0].name:=id;&#10;        j:=btab[display[level]].last; l:=j;&#10;        while nametab[j].name&#60;&#62;id do j:=nametab[j].link; &#10;        if j&#60;&#62;0     &#10;        then error(l)&#10;        else begin     &#10;          tx:=tx+1;&#10;          with nametab[tx] do&#10;          begin             &#10;            name:=id; link:=l;&#10;            kind:=k;   typ:=notyp;    ref:=0;  &#10;            lev:=level;  normal:=false;&#10;            case kind of                                            &#10;              variable,prosedure: adr:=0;&#10;              konstant:           val:=0;&#10;              typel:              size:=0&#10;            end  &#123; initial value &#125;&#10;          end;&#10;          btab[display[level]].last:=tx &#10;        end&#10;      end&#10;   end;   &#123; enter &#125;&#10;&#10;    function position(id:alfa):integer;    &#10;    var i,j:integer;&#10;    begin&#10;      nametab[0].name:=id; j:=level;&#10;      repeat&#10;        i:=btab[display[j]].last;&#10;        while nametab[i].name&#60;&#62;id do&#10;          i:=nametab[i].link;&#10;        j:=j-1&#10;      until (j&#60;0) or (i&#60;&#62;0);&#10;      if (i=0) then error(10);&#10;      position:=i&#10;    end;  &#123; position &#125;&#10;&#10;    procedure constant(fsys:symset; var c:constrec);   &#10;      var x,sign:integer;&#10;      begin&#10;      c.tp:=notyp; c.i:=0;&#10;      test(constbegsys,fsys,50);&#10;      if sym in constbegsys&#10;      then begin&#10;        if   sym=charcon&#10;         then begin&#10;           c.tp:=chars; c.i:=num;&#10;           getsym&#10;         end else&#10;           begin&#10;             sign:=1;&#10;            if sym in [plus,minus]&#10;            then begin&#10;              if sym=minus then sign:=-1;&#10;              getsym&#10;            end;&#10;            if sym=ident&#10;            then begin&#10;              x:=position(id);&#10;              if x&#60;&#62;0&#10;              then if nametab[x].kind&#60;&#62;konstant&#10;                  then error(12)&#10;                  else begin&#10;                          c.tp:=nametab[x].typ;&#10;                          c.i:=sign*nametab[x].val&#10;                  end;&#10;              getsym&#10;            end else if sym=intcon&#10;               then begin&#10;                      c.tp:=ints; c.i:=sign*num;&#10;                      getsym&#10;               end&#10;       end;&#10;       test(fsys,[],6)&#10;     end&#10;end;    &#123; constant &#125;&#10;&#10;procedure typ(fsys:symset;var tp:types; var rf,sz:integer);&#10;var  eltp:types;&#10;     elrf,x:integer;&#10;     elsz,offset,t0,t1:integer;&#10;&#10;procedure arraytyp(var aref,arsz:integer); &#10;var  eltp:types;&#10;     low,high:constrec;&#10;     elrf,elsz:integer;&#10;begin&#10;  constant([colon,rbrack,rparen,ofsym]+fsys,low);&#10;  if (low.tp&#60;&#62;ints)  and (low.tp&#60;&#62;chars)&#10;  then  error(50);&#10;  if sym=colon then getsym else error(38);&#10;  constant([rbrack,comma,rparen,ofsym]+fsys,high);&#10;  if high.tp&#60;&#62;low.tp&#10;  then begin&#10;    error(40); high.i:=low.i;&#10;  end;&#10;  enterarray(low.tp,low.i,high.i);&#10;  aref:=ax;&#10;  if sym=comma&#10;  then begin&#10;    getsym;&#10;    eltp:=arrays;&#10;    arraytyp(elrf,elsz)&#10;  end else begin&#10;    if sym=rbrack&#10;    then getsym&#10;    else begin&#10;      error(28);&#10;      if sym=rparen then getsym&#10;    end;&#10;    if sym=ofsym then getsym else error(17);&#10;    typ(fsys,eltp,elrf,elsz)&#10;  end;&#10;  with atab[aref] do&#10;  begin&#10;    arsz:=(high-low+1)*elsz; size:=arsz;&#10;    eltyp:=eltp; elref:=elrf; elsize:=elsz&#10;  end;&#10;end;   &#123; arraytyp &#125;&#10;begin  &#123; typ &#125;&#10;  tp:=notyp; rf:=0; sz:=0;&#10;  test(typebegsys,fsys,10);&#10;  if sym in typebegsys&#10;  then begin&#10;    if sym=ident&#10;    then begin&#10;       x:=position(id);&#10;       if x&#60;&#62;0&#10;       then with nametab[x] do&#10;              if kind&#60;&#62;typel&#10;              then error(19)&#10;              else begin&#10;                tp:=typ;rf:=ref;sz:=size;&#10;                if tp=notyp then error(18);&#10;              end;&#10;         getsym;&#10;    end else if sym=arraysym&#10;                then  begin&#10;                  getsym;&#10;                  if sym=lbrack&#10;                  then getsym&#10;                  else begin&#10;                    error(16);&#10;                    if sym=lparen&#10;                    then getsym&#10;                  end;&#10;                  tp:=arrays;&#10;                  arraytyp(rf,sz)&#10;                end ;&#10;         test(fsys,[],13)&#10;    end&#10;  end;       &#123;typ&#125;&#10;&#10;    procedure paramenterlist;   &#123;formal parameter list&#125;&#10;    var&#10;      tp:types;&#10;      valpar:boolean;&#10;      rf,sz,x,t0:integer;&#10;    begin&#10;      getsym;&#10;      tp:=notyp;rf:=0;sz:=0;&#10;      test([ident,varsym],fsys+[rparen],7);&#10;      while sym in [ident,varsym] do&#10;      begin&#10;        if sym &#60;&#62; varsym&#10;          then valpar:=true&#10;          else begin&#10;            getsym;&#10;            valpar:=false&#10;          end;&#10;          t0:=tx;&#10;          if sym=ident&#10;          then begin&#10;            enter(variable);&#10;            getsym&#10;          end  else error(22);&#10;          while sym=comma do&#10;          begin&#10;            getsym;&#10;            if sym=ident&#10;            then begin&#10;              enter(variable);&#10;              getsym&#10;            end  else error(22);&#10;          end;&#10;          if sym=colon&#10;          then begin&#10;            getsym;&#10;            if sym &#60;&#62; ident&#10;            then error(22)&#10;            else begin&#10;              x :=position(id); getsym;&#10;              if x&#60;&#62;0&#10;              then with nametab[x] do&#10;                if kind &#60;&#62; typel&#10;                then error(19)&#10;                else begin&#10;                  tp:= typ; rf:=ref;&#10;                  if valpar then sz:=size else sz:=1&#10;                end;&#10;            end;&#10;            test ([semicolon,rparen],[comma,ident]+fsys,14)&#10;          end else error(24);&#10;          while t0 &#60; tx do&#10;          begin&#10;            t0 :=t0+1;&#10;            with nametab[t0] do&#10;            begin&#10;              typ :=tp;ref :=rf;&#10;              adr :=dx;lev :=level;&#10;              normal :=valpar;&#10;              dx :=dx+sz&#10;            end&#10;          end;&#10;          if sym &#60;&#62; rparen&#10;          then begin&#10;            if sym=semicolon&#10;            then getsym&#10;            else begin&#10;              error(23);&#10;            if sym=comma then getsym&#10;          end;&#10;          test([ident,varsym],[rparen]+fsys,13)&#10;        end&#10;      end &#123;while&#125;;&#10;      if sym=rparen&#10;       then begin&#10;         getsym;&#10;         test([semicolon],fsys,13)&#10;       end else error(25)&#10;    end &#123;parameterlist&#125;;&#10;&#10;&#10;    procedure constdeclaration;  &#10;    var c:constrec;&#10;    begin&#10;      if sym=ident then&#10;        begin&#10;          enter(konstant);&#10;          getsym;&#10;          if sym = eql&#10;            then getsym&#10;            else&#10;              begin&#10;                error(26);&#10;                if sym=becomes then getsym&#10;              end;&#10;          constant([semicolon,comma,ident]+fsys,c);&#10;          nametab[tx].typ:=c.tp;&#10;          nametab[tx].ref:=0;&#10;          nametab[tx].val:=c.i;&#10;          if sym=semicolon then getsym else error(23)&#10;        end&#10;        else error(22);&#10;      test(fsys+[ident],[],13)&#10;    end;   &#123; constdeclaration &#125;&#10;&#10;    procedure typedeclaration;  &#10;    var&#10;      tp:types;&#10;      rf,sz,t1:integer;&#10;    begin&#10;      if sym=ident then&#10;        begin&#10;          enter(typel);&#10;          t1:=tx;&#10;          getsym;&#10;          if sym = eql then  getsym&#10;          else begin&#10;              error(26);&#10;              if sym=becomes then   getsym;&#10;          end;&#10;         typ ([semicolon,comma,ident]+fsys,tp,rf,sz);&#10;         nametab[tx].typ:=tp;&#10;         nametab[tx].ref:=rf;&#10;         nametab[tx].size:=sz;&#10;         if sym=semicolon then getsym else error(23)&#10;        end&#10;        else error(22);&#10;      test(fsys+[ident],[],13)&#10;    end;   &#123; typedeclaration &#125;&#10;&#10;&#10;    procedure vardeclaration;  &#10;    var tp:types;&#10;        t0,t1,rf,sz:integer;&#10;    begin&#10;      if sym=ident then&#10;        begin&#10;          t0:=tx;&#10;          enter(variable); getsym;&#10;          while sym = comma do&#10;          begin&#10;            getsym;&#10;            if sym =ident&#10;            then begin&#10;              enter(variable);getsym;&#10;            end else error(22);&#10;          end;&#10;          if sym = colon then getsym else error(24);&#10;          t1:=tx;&#10;          typ ([semicolon,comma,ident]+fsys,tp,rf,sz);&#10;          while t0 &#60; t1 do&#10;          begin&#10;            t0:=t0+1;&#10;            with nametab[t0] do&#10;            begin&#10;              typ:=tp;  ref:=rf;&#10;              lev:=level; adr:=dx;&#10;              normal:=true;&#10;              dx:=dx+sz&#10;            end&#10;          end;&#10;          if sym=semicolon then getsym else error(23)&#10;        end&#10;        else error(22);&#10;      test(fsys+[ident],[],13)&#10;    end;  &#123; vardeclaration &#125;&#10;&#10;    procedure procdeclaration;  &#10;    begin&#10;      getsym;&#10;      if sym &#60;&#62; ident&#10;      then  begin&#10;        error(22); id:=&#39; &#39;&#10;      end;&#10;      enter(prosedure);  &#10;      nametab[tx].normal:=true;&#10;      getsym;&#10;      block([semicolon]+fsys,level+1);&#10;      if sym = semicolon then getsym else error(23);&#10;    end;    &#123;procdeclaration&#125;&#10;&#10;    procedure listcode;&#10;    var i:integer;&#10;    begin&#10;      for i:=cx0 to cx-1 do&#10;        with code[i] do&#10;          writeln(listfile,i:4,mnemonic[f]:7,l:3,a:5)&#10;    end;  &#123; listcode &#125;&#10;&#10;    procedure statement(fsys:symset);&#10;    var i,cx1,cx2,cx3:integer;&#10;        x:item;&#10;      procedure arrayelement(fsys:symset;var x:item); forward;&#10;      procedure expression(fsys:symset;var x: item);&#10;      var relop:symbol;&#10;          y:item;&#10;        procedure simpleexpression(fsys:symset;var x:item);&#10;          var addop:symbol;&#10;              y:item;&#10;          procedure term(fsys:symset;var x: item);&#10;          var mulop:symbol;&#10;              y:item;&#10;            procedure factor(fsys:symset;var x:item);&#10;            var i:integer;&#10;            begin&#10;            x.typ:=notyp;&#10;            x.ref:=0;&#10;            test(facbegsys,fsys,13);&#10;            if sym in facbegsys then    &#123; facbegsys :=[ident,intcon,lparen,notsym,charcon];&#125;&#10;            begin&#10;              case sym of&#10;              ident :&#10;              begin&#10;                i:=position(id);&#10;                getsym;&#10;                if i=0 then error(10)&#10;                else&#10;                  with nametab[i] do&#10;                    case kind of&#10;                      konstant: begin&#10;                                  x.typ:=typ;&#10;                                  x.ref:=0;&#10;                                  gen(lit,0,val);&#10;                                end;&#10;                      variable:&#10;                        begin&#10;                          x.typ:=typ;&#10;                          x.ref:=ref;&#10;                          if (typ = ints) or (typ = bool) or(typ=chars)&#10;&#10;                          then  if normal  then gen(lod,lev,adr)&#10;                                           else gen(ilod,lev,adr)&#10;                          else  if typ=arrays then&#10;                               begin&#10;                                 if normal then gen(loda,lev,adr)&#10;                                           else gen(lod,lev,adr);&#10;                                 if sym = lbrack&#10;                                   then arrayelement(fsys,x);&#10;                                 if x.typ &#60;&#62; arrays&#10;                                   then gen(lodt,0,0)&#10;                               end&#10;                        end;&#10;                      prosedure,typel:error(41)&#10;                    end;&#10;                  end ;&#10;              intcon,charcon :&#10;                begin&#10;                  if sym = intcon then x.typ:=ints&#10;                                else x.typ:=chars;&#10;                  x.ref:=0;&#10;                  gen(lit,0,num);&#10;                  getsym&#10;                end;&#10;              lparen :&#10;                  begin&#10;                    getsym;&#10;                    expression([rparen]+fsys,x);&#10;                    if sym=rparen then getsym&#10;                    else error(25)&#10;                  end;&#10;              notsym :&#10;                  begin&#10;                    getsym;&#10;                    factor(fsys,x);&#10;                    if x.typ = bool&#10;                      then gen(nots ,0,0)&#10;                      else error(43)&#10;                  end;&#10;              end ;&#123; case &#125;&#10;              test(fsys+[rbrack,rparen],facbegsys,23)&#10;            end  &#123; of if &#125;&#10;          end;  &#123; factor &#125;&#10;        begin   &#123; term &#125;&#10;          factor(fsys+[times,divsym,modsym,andsym],x);&#10;          while sym in [times,divsym,modsym,andsym] do&#10;            begin&#10;              mulop:=sym; getsym;&#10;              factor(fsys+[times,divsym,modsym,andsym],y);&#10;              if x.typ&#60;&#62;y.typ&#10;                then begin&#10;                       error(40);&#10;                       x.typ:=notyp;&#10;                       x.ref:=0&#10;                     end&#10;                else&#10;                  begin&#10;                    if mulop=times then&#10;                        if x.typ = ints&#10;                          then gen(mult,0,0)&#10;                          else error(43);&#10;                    if  mulop=divsym then&#10;                        if x.typ = ints&#10;                          then gen(idiv,0,0)&#10;                          else error(43);&#10;                    if  mulop=modsym then&#10;                        if x.typ = ints&#10;                          then gen(imod,0,0)&#10;                          else error(43);&#10;                    if  mulop=andsym then&#10;                      if x.typ = bool&#10;                          then gen(ands,0,0)&#10;                          else error(43)&#10;            end&#10;          end&#10;        end;  &#123; term&#125;&#10;      begin  &#123; simpleexpression &#125;&#10;        if sym in [plus,minus] then&#10;          begin&#10;            addop:=sym; getsym;&#10;            term(fsys+[plus,minus,orsym],x);&#10;            if addop=minus then gen(mus,0,0)&#10;          end  else term(fsys+[plus,minus,orsym],x);&#10;        while sym in [plus,minus,orsym] do&#10;          begin addop:=sym; getsym;&#10;                term(fsys+[plus,minus,orsym],y);&#10;                if x.typ&#60;&#62;y.typ&#10;                then begin&#10;                       error(40);&#10;                       x.typ:=notyp;&#10;                       x.ref:=0&#10;                     end&#10;                else&#10;                  begin&#10;                    if addop=plus then&#10;                        if x.typ = ints&#10;                          then gen(add,0,0)&#10;                          else error(43);&#10;                    if  addop=minus then&#10;                        if x.typ = ints&#10;                          then gen(sub,0,0)&#10;                          else error(43);&#10;                    if  addop=orsym then&#10;                      if x.typ = bool&#10;                          then gen(ors,0,0)&#10;                          else error(43)&#10;                 end&#10;            end&#10;      end;   &#123; simpleexpression &#125;&#10;    begin  &#123;expression&#125;&#10;       simpleexpression([eql,neq,lss,gtr,leq,geq]+fsys,x);&#10;       while (sym in [eql,neq,lss,leq,gtr,geq]) do&#10;         begin&#10;           relop:=sym; getsym; simpleexpression(fsys,y);&#10;           if x.typ&#60;&#62; y.typ&#10;             then error(40);&#10;           case relop of&#10;             eql:gen(eq,0,0);&#10;             neq:gen(ne,0,0);&#10;             lss:gen(ls,0,0);&#10;             geq:gen(ge,0,0);&#10;             gtr:gen(gt,0,0);&#10;             leq:gen(le,0,0)&#10;           end;&#10;           x.typ:=bool&#10;         end&#10;    end;       &#123; expression &#125;&#10;&#10;      procedure arrayelement(fsys:symset;var x:item);&#10;      var cc:integer;&#10;          addr,p:index;&#10;          y:item;&#10;      begin&#10;      p:=x.ref;&#10;      if sym=lbrack then&#10;        begin&#10;          repeat&#10;            getsym;&#10;            expression(fsys+[comma],y);&#10;            if x.typ &#60;&#62; arrays then error(40)&#10;            else&#10;              begin&#10;                if y.typ &#60;&#62; atab[p].inxtyp then error(44);&#10;                gen(lit,0,atab[p].low);&#10;                gen(sub,0,0);&#10;                gen(lit,1,atab[p].elsize);&#10;                gen(mult,0,0);&#10;                gen(add,0,0);&#10;                x.typ:=atab[p].eltyp;&#10;                x.ref:=atab[p].elref;&#10;                p:=atab[p].elref;&#10;              end&#10;          until sym &#60;&#62; comma;&#10;&#10;          if sym=rbrack then getsym else error(28);&#10;        end else error(16);&#10;      test(fsys,[],13);&#10;    end;         &#123;arrayelement&#125;&#10;&#10;  procedure assignment;  &#10;    var x,y:item;&#10;      begin&#10;        i:=position(id);&#10;        if i=0 then error(10)&#10;        else&#10;          if nametab[i].kind&#60;&#62;variable then&#10;            begin  &#123; giving value to non-variation &#125;&#10;              error(30);  i:=0&#10;            end;&#10;        getsym;&#10;        x.typ:=nametab[i].typ;&#10;        x.ref:=nametab[i].ref;&#10;        with nametab[i] do&#10;          if normal&#10;            then gen(loda,lev,adr)   &#10;            else gen(lod,lev,adr);  &#10;        if sym = lbrack  &#10;            then arrayelement(fsys+[becomes],x);&#10;        if sym = becomes then getsym&#10;              else begin&#10;                     error(33);&#10;                     if sym=eql then getsym&#10;                   end;&#10;         expression(fsys,y);&#10;         if x.typ &#60;&#62; y.typ then error(40)&#10;         else&#10;           if x.typ = arrays&#10;             then if x.ref = y.ref&#10;                     then gen(cpyb,0,atab[x.ref].size)  &#10;                     else error(40)&#10;             else gen(sto,0,0);   &#10;      end;      &#10;&#10;&#10;                        &#10;     procedure ifstatement;         &#10;       var x:item;&#10;       begin&#10;         getsym; expression([thensym,dosym]+fsys,x);&#10;         if x.typ &#60;&#62; bool then error(34);&#10;         if sym=thensym then getsym else error(35);&#10;         cx1:=cx; gen(jpc,0,0);  &#10;         statement(fsys+[elsesym]);   &#10;         if sym = elsesym&#10;           then  begin&#10;             getsym;&#10;             cx2:=cx; gen(jmp,0,0);&#10;             code[cx1].a:=cx;   &#10;             labtab[lx]:=cx;lx:=lx+1;&#10;             statement(fsys);&#10;             code[cx2].a:=cx;   &#10;             labtab[lx]:=cx;lx:=lx+1;&#10;           end&#10;         else&#10;             begin     &#10;               code[cx1].a:=cx;&#10;               labtab[lx]:=cx;lx:=lx+1;&#10;             end&#10;       end;           &#123;ifstatement&#125;&#10; &#10;     procedure casestatement;   &#123;case&#125;&#10;         var x:item;&#10;             coni,conj:integer; &#10;         begin&#10;                getsym;cx1:=cx;&#10;                expression([ofsym]+fsys,x);cx2:=cx;&#10;              if (x.typ = ints) or (x.typ = chars)then &#10;               begin&#10;                if sym=ofsym then&#10;                begin&#10;                 getsym;conj:=0;&#10;                 while sym&#60;&#62;elsesym do &#10;                 begin&#10;                     if (sym = intcon) or (sym = charcon) then&#10;                     begin&#10;                    coni:=cx1;&#10;                      if conj&#60;&#62;0 then&#10;                      begin&#10;                      while coni&#60;cx2 do&#10;                      begin&#10;                        code[cx]:=code[coni];&#10;                         cx:=cx+1;&#10;                         coni:=coni+1;&#10;                      end&#10;                      end;&#10;                      conj:=1;&#10;                      gen(lit,0,num);&#10;                      coni:=cx1;&#10;                      end&#10;                      else error(12);&#10;                      getsym;&#10;                       if sym=colon then&#10;                       begin&#10;                          getsym;&#10;                          gen(eq,0,0);&#10;                          cx2:=cx;&#10;                            gen(jpc,0,0);&#10;                            statement([semicolon]+fsys);&#10;                       if sym=semicolon then&#10;                       begin&#10;                        getsym;&#10;                        labtab[lx]:=cx;lx:=lx+1;&#10;                        gen(jmp,0,0);&#10;                        code[cx2].a:=cx&#10;                         end&#10;                       else error(23)&#10;                      end&#10;                      else  error(24)&#123;colon&#125;&#10;                     end;&#10;                   if sym=elsesym then&#10;                     begin&#10;                        getsym;&#10;                    statement([endsym]+fsys);&#10;                        lx:=lx-1;&#10;                         while lx&#62;=0 do&#10;                         begin code[labtab[lx]].a:=cx;&#10;                        lx:=lx-1&#10;                         end&#10;                  end;&#10;                  if sym=endsym then getsym&#10;                  else error(36)&#10;              end&#10;              else error(17)&#10;             end&#10;          end;&#10;    &#10;&#10;&#10;    procedure compound;   &#10;      begin&#10;        getsym; statement([semicolon,endsym]+fsys);&#10;        while sym in ([semicolon]+statbegsys) do&#10;        begin&#10;          if sym=semicolon then getsym else error(23);&#10;          statement([semicolon,endsym]+fsys) &#10;        end;&#10;        if sym=endsym then getsym else error(36)&#10;      end;         &#123;compound&#125;&#10;&#10;    procedure whilestatement; &#10;      var x:item;&#10;      begin&#10;        getsym;&#10;        labtab[lx]:=cx;lx:=lx+1;&#10;        cx1:=cx; expression([dosym]+fsys,x);    &#10;        if x.typ &#60;&#62; bool then error(34);&#10;        cx2:=cx; gen(jpc,0,0);&#10;        if sym=dosym then getsym else error(37);&#10;        statement(fsys); gen(jmp,0,cx1); code[cx2].a:=cx;&#10;        labtab[lx]:=cx;lx:=lx+1&#10;      end;&#10;      &#10;      procedure repeatstatement;&#123;repeat&#125;&#10;      var x:item;&#10;      begin&#10;        getsym;cx1:=cx; labtab[lx]:=cx;lx:=lx+1;&#10;        statement([untilsym]+fsys);&#10;        if sym&#60;&#62;semicolon then error(23);&#10;        getsym;&#10;        while (not (sym in ([untilsym]))) do&#10;          begin&#10;           statement([untilsym]+fsys);&#10;           if sym&#60;&#62;semicolon then error(23);&#10;           getsym&#10;          end;&#10;          &#10;        if sym=untilsym then &#10;          begin&#10;            getsym;&#10;            expression([endsym]+fsys,x);&#10;            if x.typ &#60;&#62; bool then error(34); &#10;            gen(jpc,0,cx1);labtab[lx]:=cx;lx:=lx+1&#10;          end&#10;      end;&#10;        &#10;                &#10;procedure forstatement;&#123;for&#125;&#10;var x,ini,fin:item;&#10;begin&#10;     getsym;&#10;     if sym=ident then&#10;     begin &#10;             i:=position(id);getsym;&#10;             if i=0 then error(10)&#10;             else&#10;                  if nametab[i].kind&#60;&#62;variable then&#10;                     begin&#10;                     error(30);i:=0&#10;                     end &#10;                  else&#10;                     begin&#10;                        x.typ:=nametab[i].typ;&#10;            x.ref:=nametab[i].ref; &#10;            if nametab[i].normal  &#10;            then gen(loda,nametab[i].lev,nametab[i].adr)&#10;            else gen(lod,nametab[i].lev,nametab[i].adr)&#10;           end;&#10;       if sym=becomes then &#10;       begin&#10;           getsym;&#10;           expression([tosym]+fsys,ini);&#10;             if  ini.typ&#60;&#62;ints then error(12)&#10;             else begin&#10;                     gen(sto,0,0);&#10;                     if sym=tosym then&#10;                         begin&#10;                            getsym;cx1:=cx;labtab[lx]:=cx;lx:=lx+1;&#10;                            gen(loda,nametab[i].lev,nametab[i].adr);&#10;                            gen(lodt,0,0);&#10;                            expression([dosym]+fsys,fin);&#10;                          if sym=dosym then&#10;                               begin&#10;                                 gen(le,0,0);&#10;                                 cx2:=cx;labtab[lx]:=cx;lx:=lx+1;&#10;                                 gen(jpc,0,0);&#10;                                     getsym;&#10;                                   statement(fsys);&#10;                                     if nametab[i].normal then&#10;                                     begin&#10;                                         gen(loda,nametab[i].lev,nametab[i].adr);&#10;                                         gen(loda,nametab[i].lev,nametab[i].adr);&#10;                           gen(lodt,0,0)&#10;                                     end&#10;                                     else gen(lod,nametab[i].lev,nametab[i].adr);&#10;                                     gen(lit,0,1);&#10;                                     gen(add,0,0);&#10;                         gen(sto,0,0);&#10;                         gen(jmp,0,cx1);&#10;                         code[cx2].a:=cx&#10;                                 end&#10;                         end&#10;                      end&#10;       end&#10;   end&#10;   else error(33)&#10;end;&#10;                    &#10;           &#10;&#10;&#10;           &#10;         &#10;&#10;&#10;    procedure call;       &#10;    var      x:  item;&#10;             lastp,cp,i,j,k:integer;&#10;    procedure stanproc(i:integer);&#10;    var n:integer;&#10;    begin&#10;      if i =6  then&#10;        begin    &#123; read &#125;&#10;          getsym;&#10;          if sym=lparen then&#10;          begin&#10;            repeat&#10;              getsym;&#10;              if sym=ident then&#10;                begin&#10;                  n:=position(id); getsym;&#10;                  if n=0 then error(10)&#10;                    else&#10;                      if nametab[n].kind&#60;&#62;variable then&#10;                         begin error(30); n:=0 end&#10;                      else&#10;                        begin&#10;                          x.typ:=nametab[n].typ;&#10;                          x.ref:=nametab[n].ref;&#10;                          if nametab[n].normal&#10;                            then gen(loda,nametab[n].lev,nametab[n].adr)&#10;                            else gen(lod,nametab[n].lev,nametab[n].adr);&#10;                          if sym = lbrack&#10;                             then arrayelement(fsys+[comma],x);&#10;                          if x.typ = ints&#10;                            then gen(red,0,0)&#10;                            else if x.typ = chars&#10;                                   then gen(red,0,1)&#10;                                   else error(43)&#10;                        end&#10;                end&#10;                else error(22)&#10;              until sym&#60;&#62;comma;&#10;              if sym&#60;&#62;rparen then error(25)&#10;                               else  getsym&#10;            end&#10;            else error(32)&#10;          end&#10;          else&#10;            if i = 7 then&#10;              begin        &#123; write &#125;&#10;                getsym;&#10;                if sym=lparen then&#10;                  begin&#10;                    repeat&#10;                      getsym;&#10;                      expression([rparen,comma]+fsys,x);&#10;                      if x.typ = ints&#10;                        then gen(wrt,0,0)&#10;                        else if x.typ = chars&#10;                               then gen(wrt,0,1)&#10;                               else error(43)&#10;                    until sym&#60;&#62;comma;&#10;                    if sym&#60;&#62;rparen then error(25);&#10;                    getsym&#10;                  end&#10;                else error(32)&#10;             end&#10;    end;    &#123; standproc &#125;&#10;    begin    &#123; call &#125;&#10;      getsym;&#10;      if sym = ident  then&#10;      begin&#10;        i:=position(id);&#10;        if nametab[i].kind = prosedure then&#10;        begin&#10;          if nametab[i].lev = 0 then stanproc(i)&#10;          else begin&#10;            getsym;&#10;            gen(opac,0,0);  &#123;open active record&#125;&#10;            lastp :=btab[nametab[i].ref].lastpar;&#10;            cp :=i;&#10;            if sym=lparen&#10;            then begin &#123;actual parameter list&#125;&#10;            repeat&#10;              getsym;&#10;              if cp&#62;=lastp&#10;              then error(29)&#10;              else begin&#10;                cp :=cp+1;&#10;                if nametab[cp].normal  then&#10;                begin &#123;value parameter&#125;&#10;                  expression(fsys+[comma,colon,rparen],x);&#10;                  if x.typ = nametab[cp].typ then&#10;                    begin&#10;                      if x.ref &#60;&#62; nametab[cp].ref&#10;                        then error(31)&#10;                        else if x.typ = arrays&#10;                               then gen(lodb,0,atab[x.ref].size)&#10;                    end&#10;                  else error(31)&#10;                end else begin &#123;variable parameter&#125;&#10;                  if sym &#60;&#62; ident&#10;                  then error(22)&#10;                  else begin&#10;                    k:=position(id);&#10;                    getsym;&#10;                    if k&#60;&#62;0&#10;                    then begin&#10;                      if nametab[k].kind&#60;&#62;variable then error (30);&#10;                      x.typ :=nametab[k].typ;&#10;                      x.ref :=nametab[k].ref;&#10;                      if nametab[k].normal&#10;                      then gen(loda,nametab[k].lev,nametab[k].adr)&#10;                      else gen(lod,nametab[k].lev,nametab[k].adr);&#10;                      if sym = lbrack&#10;                        then  arrayelement(fsys+[comma,rparen],x);&#10;                      if    (nametab[cp].typ&#60;&#62;x.typ)&#10;                        or (nametab[cp].ref&#60;&#62;x.ref)&#10;                         then error(31);&#10;                    end&#10;                  end&#10;                end &#123;variable parameter&#125;&#10;              end;&#10;              test([comma,rparen],fsys,13)&#10;            until sym &#60;&#62; comma;&#10;            if sym=rparen then getsym  else error(25)&#10;          end;&#10;          if cp &#60; lastp then error(39);&#123;too few actual parameters&#125;&#10;          gen(cal,nametab[i].lev,nametab[i].adr);&#10;          if nametab[i].lev&#60;level then gen(udis,nametab[i].lev,level)&#10;        end&#10;      end else error(51)&#10;    end else error(22);&#10;    test(fsys+[ident],[],13)&#10;  end &#123;call&#125;;&#10;    begin  &#123; statement &#125;&#10;      test(statbegsys+[ident],fsys,13);&#10;      if sym=ident then  assignment&#10;      else if sym=callsym then call&#10;      else   if sym=ifsym then  ifstatement&#10;      else   if sym=casesym then  casestatement&#10;      else   if sym=repeatsym then repeatstatement&#10;        else   if sym=forsym then forstatement&#10;      else   if sym=beginsym then compound&#10;      else    if sym=whilesym then whilestatement;&#10;      test(fsys+[elsesym],[],13)&#10;    end;  &#123; statement &#125;&#10;  begin   &#123; block &#125;&#10;    prt:=tx;  &#123;tx&#20026;TABLE&#34920;&#30340;&#34920;&#22836;&#32034;&#24341;&#125;&#10;    dx:=3;  &#123;&#27599;&#20010;&#36807;&#31243;&#20013;&#21464;&#37327;&#30340;&#30456;&#23545;&#36215;&#22987;&#20301;&#32622;&#22312;BLOCK&#20869;&#32622;&#21021;&#20540;DX&#8758;=3&#125;&#10;    tx0:=tx; nametab[tx].adr:=cx;&#10;    if level &#62; levmax then error(4);&#10;    enterblock ;&#10;    prb:=bx;  display[level]:=bx;&#10;    nametab[prt].typ:=notyp;  nametab[prt].ref:=prb;&#10;&#10;    if(sym=lparen) and (level&#62;1)&#10;      then&#10;        begin&#10;          paramenterlist;&#10;          if sym=semicolon then getsym&#10;                           else error(23)&#10;        end&#10;      else  if level&#62;1 then&#10;              if sym=semicolon then getsym&#10;                            else error(23);&#10;    btab[prb].lastpar:=tx;&#10;    btab[prb].psize:=dx;&#10;&#10;    gen(jmp,0,0);  &#123; jump from declaration part to statement part &#125;&#10;    repeat&#10;      if sym=constsym then&#10;        begin&#10;          getsym;&#10;          repeat&#10;            constdeclaration;&#10;          until sym&#60;&#62;ident&#10;        end;&#10;      if sym=typesym then&#10;        begin&#10;          getsym;&#10;          repeat&#10;            typedeclaration;&#10;          until sym&#60;&#62;ident&#10;        end;&#10;      if sym=varsym then&#10;        begin&#10;          getsym;&#10;          repeat&#10;            vardeclaration;&#10;          until sym&#60;&#62;ident;&#10;        end;&#10;      while sym=procsym do   procdeclaration;&#10;      test(statbegsys+[ident],declbegsys,13)&#10;    until not (sym in declbegsys);&#10;    code[nametab[tx0].adr].a:=cx;  &#123;back enter statement code&#39;s start adr. &#125;&#10;    labtab[lx]:=cx;lx:=lx+1;&#10;    with nametab[tx0] do&#10;      begin&#10;        adr:=cx;  &#123;code&#39;s start address &#125;&#10;      end;&#10;    cx0:=cx;&#10;    gen(entp,level,dx);  &#123; block entry &#125;&#10;    statement([semicolon,endsym]+fsys);&#10;    if level&#62;1 then gen(retp,0,0)  &#123;return&#125;&#10;               else gen(endp,0,0);  &#123; end prograam &#125;&#10;    test(fsys,[],13);&#10;    listcode;&#10;  end;   &#123; block &#125;&#10;&#10;&#123;************************************************************************&#125;&#10;begin  &#123; main &#125;&#10;  writeln(&#39;Please input source program file name:&#39;);&#10;  readln(sfilename);&#10;  assign(sfile,sfilename);&#10;  reset(sfile);&#10;&#10;  fsplit(sfilename,dir, name,ext);  &#10;  listfilename:=dir +name+&#39;.LST&#39;;&#10;  assign(listfile,listfilename);&#10;  rewrite(listfile);&#10;&#10;  initial;&#10;  enterpreid;&#10;  getsym;&#10;  if sym = programsym then&#10;    begin&#10;      getsym;&#10;      if sym = ident then&#10;        begin&#10;          getsym;&#10;          if sym = semicolon then getsym&#10;          else error(23)&#10;        end&#10;        else error(22)&#10;    end&#10;    else error(15);&#10;    test(declbegsys+[beginsym],[],13);&#10;  block([period]+declbegsys+statbegsys,1);&#10;  if sym&#60;&#62;period then error(38);&#10;  if err=0 then&#10;      begin&#10;       write(&#39;SUCCESS&#39;);&#10;       assign(fcode,dir+name+&#39;.pld&#39;);&#10;       rewrite(fcode);&#10;       for i:=0 to cx do&#10;         write(fcode,code[i]);&#10;       close(fcode);&#10;       assign(labfile,dir+name+&#39;.lab&#39;);&#10;       rewrite(labfile);&#10;       for i:=0 to lx do&#10;         write(labfile,labtab[i]);&#10;       close(labfile)&#10;      end&#10;  else write(err,&#39;ERRORS IN PROGRAM&#39;);&#10;  writeln;&#10;  close(sfile);&#10;  close(listfile)&#10; end.  &#123; of whole program  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码">测试代码</h4><h5 id="case">case</h5><figure class="highlight pl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">program fsj;</span><br><span class="line">var n:integer;</span><br><span class="line">    a:char;   </span><br><span class="line">begin</span><br><span class="line">    n:=<span class="number">2</span>;</span><br><span class="line">    a:=<span class="string">'f'</span>;</span><br><span class="line">    case a of</span><br><span class="line">     <span class="number">1</span>: call <span class="keyword">write</span>(<span class="number">1</span>);</span><br><span class="line">     <span class="string">'f'</span>: call <span class="keyword">write</span>(n);</span><br><span class="line">    <span class="keyword">else</span> call <span class="keyword">write</span>(<span class="number">2</span>)</span><br><span class="line">   end</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>
<h5 id="repeat">repeat</h5><figure class="highlight pl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">program fsj;</span><br><span class="line">var n:integer;  </span><br><span class="line">begin</span><br><span class="line">   n:=<span class="number">1</span>;</span><br><span class="line">   repeat </span><br><span class="line">     n:=n+<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">until</span> n=<span class="number">5</span>;</span><br><span class="line">call <span class="keyword">write</span>(n)</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>
<h5 id="for">for</h5><figure class="highlight pl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">program fsj;</span><br><span class="line">var i,sum:integer;  </span><br><span class="line">begin</span><br><span class="line">  sum:=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">3</span> to <span class="number">7</span> <span class="keyword">do</span></span><br><span class="line">     sum:=sum+i*<span class="number">2</span>;</span><br><span class="line">  call <span class="keyword">write</span>(sum)</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/compiler/">compiler</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://yoursite.com/2015/06/27/PL-0-language-compiler-in-PASCAL/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/OpenGL/">OpenGL</a><small>1</small></li>
  
    <li><a href="/tags/compiler/">compiler</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 Victor Lee
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.useso.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>